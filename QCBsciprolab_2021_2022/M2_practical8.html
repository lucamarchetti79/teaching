

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>Module 2, Practical 8 &mdash; QCB Scientific Programming Lab</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script type="text/javascript" src="_static/jquery.js"></script>
        <script type="text/javascript" src="_static/underscore.js"></script>
        <script type="text/javascript" src="_static/doctools.js"></script>
        <script type="text/javascript" src="_static/language_data.js"></script>
        <script type="text/javascript" src="_static/js/jupman.js"></script>
        <script type="text/javascript" src="_static/js/pytutor-embed.bundle.min.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script async="async" type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.5/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
        <script type="text/x-mathjax-config">MathJax.Hub.Config({"tex2jax": {"inlineMath": [["$", "$"], ["\\(", "\\)"]], "processEscapes": true, "ignoreClass": "document", "processClass": "math|output_area"}})</script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/jupman.css" type="text/css" />
  <link rel="stylesheet" href="_static/css/jupman-web.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="Module 2, Practical 9" href="M2_practical9.html" />
    <link rel="prev" title="Module 2, Practical 7" href="M2_practical7.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >
          

          
            <a href="toc-page.html" class="icon icon-home"> QCB Scientific Programming Lab
          

          
          </a>

          
            
            
              <div class="version">
                dev
              </div>
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="index.html">Scientific Programming for QCB</a></li>
<li class="toctree-l1"><a class="reference internal" href="index.html#General-Info">General Info</a><ul>
<li class="toctree-l2"><a class="reference internal" href="index.html#Timetable-and-lecture-rooms">Timetable and lecture rooms</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#Zoom-links">Zoom links</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#Equipment">Equipment</a></li>
<li class="toctree-l2"><a class="reference internal" href="index.html#Acknowledgements">Acknowledgements</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical1.html">Module 1, Practical 1</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical1.html#Setting-up-the-environment">Setting up the environment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical1.html#Linux-on-windows">Linux on windows</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical1.html#A-dual-boot-system">A dual boot system</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical1.html#Our-toolbox">Our toolbox</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical1.html#Installing-Python3-in-Linux">Installing Python3 in Linux</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical1.html#Installing-Python3-in-Windows/Mac">Installing Python3 in Windows/Mac</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical1.html#OPTION-1:">OPTION 1:</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical1.html#OPTION-2-(easier):">OPTION 2 (easier):</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical1.html#The-console">The console</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical1.html#Visual-Studio-Code">Visual Studio Code</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical1.html#The-debugger">The debugger</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical1.html#A-quick-Jupyter-primer-(just-for-your-information,-skip-if-not-interested)">A quick Jupyter primer (just for your information, skip if not interested)</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical1.html#Installation">Installation</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical1.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical2.html">Module 1, Practical 2</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical2.html#Modules">Modules</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical2.html#Objects">Objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical2.html#Variables">Variables</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical2.html#Numeric-types">Numeric types</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical2.html#Integers">Integers</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical2.html#Booleans">Booleans</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical2.html#Real-numbers">Real numbers</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical2.html#Strings">Strings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical2.html#Methods-for-the-str-object">Methods for the str object</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical2.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical3.html">Module 1, Practical 3</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical3.html#Lists">Lists</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical3.html#Operators-for-lists">Operators for lists</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical3.html#Methods-of-the-class-list">Methods of the class list</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical3.html#From-strings-to-lists,-the-split-method">From strings to lists, the <code class="docutils literal notranslate"><span class="pre">split</span></code> method</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical3.html#And-back-to-strings-with-the-join-method">And back to strings with the <code class="docutils literal notranslate"><span class="pre">join</span></code> method</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical3.html#Tuples">Tuples</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical3.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical4.html">Module 1, Practical 4</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical4.html#Execution-flow">Execution flow</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical4.html#Conditionals">Conditionals</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical4.html#The-basic-if---else-statement">The basic <em>if - else</em> statement</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical4.html#The-if---elif---else-statement">The <em>if - elif - else</em> statement</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical4.html#Loops">Loops</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical4.html#For-loop">For loop</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical4.html#Looping-over-a-range">Looping over a range</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical4.html#Nested-for-loops">Nested for loops</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical4.html#While-loops">While loops</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical4.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical5.html">Module 1, Practical 5</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical5.html#More-on-loops">More on loops</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical5.html#Ternary-operator">Ternary operator</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical5.html#Break-and-continue">Break and continue</a><ul>
<li class="toctree-l4"><a class="reference internal" href="M1_practical5.html#Continue-statement">Continue statement</a></li>
<li class="toctree-l4"><a class="reference internal" href="M1_practical5.html#Break-statement">Break statement</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical5.html#List-comprehension">List comprehension</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical5.html#Dictionaries">Dictionaries</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical5.html#Functions-working-on-dictionaries">Functions working on dictionaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical5.html#Dictionary-methods">Dictionary methods</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical5.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical6.html">Module 1, Practical 6</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical6.html#Functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical6.html#Namespace-and-variable-scope">Namespace and variable scope</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical6.html#Argument-passing">Argument passing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical6.html#Positional-arguments">Positional arguments</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical6.html#Passing-arguments-by-keyword">Passing arguments by keyword</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical6.html#Specifying-default-values">Specifying default values</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical6.html#File-input-and-output">File input and output</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical6.html#Opening-a-file">Opening a file</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical6.html#Closing-a-file">Closing a file</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical6.html#Reading-from-a-file">Reading from a file</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical6.html#Writing-to-a-file">Writing to a file</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical6.html#String-formatting-with-format">String formatting with format</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical6.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical7.html">Module 1, Practical 7</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical7.html#Recursive-functions">Recursive functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical7.html#Exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical8.html">Module 1, Practical 8</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical8.html#Functions">Functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical8.html#Getting-input-from-the-command-line">Getting input from the command line</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical8.html#Argparse">Argparse</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical8.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical9.html">Module 1, Practical 9</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical9.html#Libraries-installation">Libraries installation</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical9.html#Pandas">Pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical9.html#Series">Series</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#How-to-define-and-access-a-Series">How to define and access a Series</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#Operator-broadcasting">Operator broadcasting</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#Filtering">Filtering</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#Missing-data">Missing data</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#Computing-stats">Computing stats</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical9.html#Plotting-data">Plotting data</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical9.html#Pandas-DataFrames">Pandas DataFrames</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#Define-a-DataFrame">Define a DataFrame</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#Loading-data-from-external-files">Loading data from external files</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#Extract-values-by-row-and-column">Extract values by row and column</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#Broadcasting,-filtering-and-computing-stats">Broadcasting, filtering and computing stats</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#Merging-DataFrames">Merging DataFrames</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical9.html#Grouping">Grouping</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical9.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical10.html">Module 1, Practical 10</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Numpy">Numpy</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Numpy-ndarray">Numpy ndarray</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Random-arrays">Random arrays</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Numpy-to-and-from-pandas">Numpy to and from pandas</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Reshaping">Reshaping</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Iterating-over-arrays-and-Indexing">Iterating over arrays and Indexing</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Broadcasting-and-arithmetic-functions">Broadcasting and arithmetic functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Filtering">Filtering</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Linear-algebra">Linear algebra</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Matplotlib">Matplotlib</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical10.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical11.html">Module 1, Practical 11</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical11.html#Biopython">Biopython</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical11.html#Installation-of-Biopython">Installation of Biopython</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical11.html#General-overview">General overview</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical11.html#Sequence-objects">Sequence objects</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical11.html#Looping,-slicing-and-concatenation">Looping, slicing and concatenation</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical11.html#Complement-and-reverse-complement">Complement and reverse complement</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical11.html#Transcription-and-translation">Transcription and translation</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical11.html#MutableSeq">MutableSeq</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical11.html#Sequence-annotation">Sequence annotation</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical11.html#Sequence-I/O">Sequence I/O</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical11.html#BioSeqIO.parse()">BioSeqIO.parse()</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical11.html#Sequences-as-dictionaries">Sequences as dictionaries</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical11.html#Writing-sequence-files">Writing sequence files</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical11.html#Multiple-sequence-alignment">Multiple sequence alignment</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical11.html#Parsing-multiple-sequence-alignments">Parsing multiple sequence alignments</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical11.html#Writing-multiple-sequence-alignments">Writing multiple sequence alignments</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical11.html#Manipulating-alignments">Manipulating alignments</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical11.html#Biopython’s-pairwise2-alignment">Biopython’s pairwise2 alignment</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical11.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M1_practical12.html">Module 1, Practical 12</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M1_practical12.html#Biopython">Biopython</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical12.html#BLAST">BLAST</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M1_practical12.html#The-function-qblast">The function qblast</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical12.html#Parsing-qblast-output">Parsing qblast output</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical12.html#Saving-results-to-file">Saving results to file</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical12.html#Open-a-blast-.XML-file">Open a blast .XML file</a></li>
<li class="toctree-l3"><a class="reference internal" href="M1_practical12.html#The-BLAST-record-class">The BLAST record class</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical12.html#Getting-data-from-NCBI">Getting data from NCBI</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical12.html#Getting-data-from-ExPASy">Getting data from ExPASy</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical12.html#3D-structure-and-PDB">3D structure and PDB</a></li>
<li class="toctree-l2"><a class="reference internal" href="M1_practical12.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M2_practical1.html">Module 2, Practical 1</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M2_practical1.html#Object-Oriented-Programming">Object Oriented Programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical1.html#Classes,-Methods-and-Objects">Classes, Methods and Objects</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical1.html#Self">Self</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical1.html#Definition-of-a-class">Definition of a class</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical1.html#The-life-cycle-of-classes-and-objects-in-a-program:">The life-cycle of classes and objects in a program:</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical1.html#Encapsulation">Encapsulation</a></li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical1.html#Special-methods">Special methods</a></li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical1.html#Inheritance-and-overriding">Inheritance and overriding</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical1.html#Exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical1.html#Lambda-functions">Lambda functions</a></li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical1.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M2_practical2.html">Module 2, Practical 2</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M2_practical2.html#Testing">Testing</a></li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical2.html#Unit-testing">Unit testing</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical2.html#Exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical2.html#Measuring-time">Measuring time</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical2.html#id1">Exercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical2.html#Measuring-memory">Measuring memory</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical2.html#id2">Exercise</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M2_practical3.html">Module 2, Practical 3</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M2_practical3.html#Complexity">Complexity</a></li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical3.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M2_practical4.html">Module 2, Practical 4</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M2_practical4.html#Regular-expressions">Regular expressions</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical4.html#Basic-Patterns">Basic Patterns</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical4.html#Group-extraction">Group extraction</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical4.html#Exercises">Exercises</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical4.html#re.compile">re.compile</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical4.html#Substitution">Substitution</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical4.html#Exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical4.html#id1">Exercises</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M2_practical5.html">Module 2, Practical 5</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M2_practical5.html#Sorting-algorithms">Sorting algorithms</a></li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical5.html#Selection-sort">Selection sort</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical5.html#A-base-class-for-sorting-algorithms">A base class for sorting algorithms</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical5.html#Exercise-(implementation)">Exercise (implementation)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical5.html#Insertion-sort">Insertion sort</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical5.html#id1">Exercise (implementation)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical5.html#Merge-sort-and-Quick-sort">Merge sort and Quick sort</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical5.html#Merge-sort">Merge sort</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical5.html#Exercise-(Implementation)">Exercise (Implementation)</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical5.html#Quick-sort">Quick sort</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical5.html#id3">Exercise (Implementation)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical5.html#Exercise-(algorithm-benchmark)">Exercise (algorithm benchmark)</a></li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical5.html#Reflection">Reflection</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical5.html#Exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical5.html#Exercise-(Counting-Sort)">Exercise (Counting Sort)</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M2_practical6.html">Module 2, Practical 6</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M2_practical6.html#Data-structures">Data structures</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical6.html#Abstract-Data-Types-(ADTs)">Abstract Data Types (ADTs)</a><ul>
<li class="toctree-l4"><a class="reference internal" href="M2_practical6.html#ADT:-Sequence">ADT: Sequence</a></li>
<li class="toctree-l4"><a class="reference internal" href="M2_practical6.html#ADT:-Set">ADT: Set</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical6.html#Exercise-(set-implementation)">Exercise (set implementation)</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical6.html#ADT:-dictionary">ADT: dictionary</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical6.html#Linked-lists">Linked lists</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical6.html#Example:-bidirectional-linked-list">Example: bidirectional linked list</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical6.html#Exercise-(complete-bidirectional-list)">Exercise (complete bidirectional list)</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical6.html#Exercise-(circular-list)">Exercise (circular list)</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical6.html#Stacks">Stacks</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical6.html#Exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical6.html#Queues">Queues</a></li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical6.html#Collections">Collections</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical6.html#id1">Exercise</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M2_practical7.html">Module 2, Practical 7</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M2_practical7.html#Trees">Trees</a></li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical7.html#ADT:-Binary-Tree">ADT: Binary Tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical7.html#Exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical7.html#Tree-visit">Tree visit</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical7.html#Binary-Tree-visits:-DFS">Binary Tree visits: DFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical7.html#Binary-Tree-visits:-BFS">Binary Tree visits: BFS</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical7.html#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical7.html#ADT:-Generic-Tree">ADT: Generic Tree</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical7.html#Exercise-(implementation)">Exercise (implementation)</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Module 2, Practical 8</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#Graphs">Graphs</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Graph-ADT">Graph ADT</a></li>
<li class="toctree-l2"><a class="reference internal" href="#Implementation-as-adjacency-matrix">Implementation as adjacency matrix</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#Exercises">Exercises</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="#Implementation-as-(adjacency)-linked-list">Implementation as (adjacency) linked list</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#id1">Exercises</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M2_practical9.html">Module 2, Practical 9</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M2_practical9.html#Graphs-recap">Graphs recap</a></li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical9.html#Visits">Visits</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical9.html#Depth-First-Search-(DFS)">Depth First Search (DFS)</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical9.html#Exercises">Exercises</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical9.html#Breadth-First-Search-(BFS)">Breadth First Search (BFS)</a></li>
<li class="toctree-l3"><a class="reference internal" href="M2_practical9.html#Exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical9.html#id1">Exercise</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="M2_practical10.html">Module 2, Practical 10</a><ul>
<li class="toctree-l2"><a class="reference internal" href="M2_practical10.html#Dynamic-programming">Dynamic programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical10.html#Excercise">Excercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical10.html#Finding-(the-optimal)-overlaps-among-DNA-strings">Finding (the optimal) overlaps among DNA strings</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical10.html#Exercise">Exercise</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="M2_practical10.html#Greedy-programming">Greedy programming</a><ul>
<li class="toctree-l3"><a class="reference internal" href="M2_practical10.html#Exercises">Exercises</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="toc.html"> </a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="toc-page.html">QCB Scientific Programming Lab</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          


    <div id='jupman-langs'></div>

    <!-- SMALL TEMPLATE FOR LANGUAGES (VERY CUSTOM FOR softpython.org !!)
    <script>
    var hn = window.location.hostname;
    var pn = window.location.pathname;

    if (hn.includes('softpython.org')){
        JUPMAN_LANG = hn.slice(0,window.location.hostname.indexOf('.'));
    } else if (pn.includes('/_build/html')){
        var pos = pn.indexOf('/_build/html');
        JUPMAN_LANG = pn.slice(pos-2, pos);
    } else {
        JUPMAN_LANG = 'en';
    }
    console.log('JUPMAN_LANG=',JUPMAN_LANG);
    </script>
    -->
    
    
     <!-- <li> <h2 style="background-color:red; color:yellow">WARNING! THIS VERSION IS OLD !  <br/>
    <a style=" text-decoration: underline;" href="https://jupman.readthedocs.io/en/latest">GOT TO LATEST VERSION</a></li>
 </h2></li>-->
    <!-- Commented because doesn't work with sections,
         see https://github.com/DavidLeoni/jupman/issues/39
    <li><a href="toc-page.html">Docs</a> &raquo;</li>
    
        <li><a href="toc.html"> </a> &raquo;</li>
    
    <li>Module 2, Practical 8</li>
    -->

          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container,
div.nbinput.container div.prompt,
div.nbinput.container div.input_area,
div.nbinput.container div[class*=highlight],
div.nbinput.container div[class*=highlight] pre,
div.nboutput.container,
div.nboutput.container div.prompt,
div.nboutput.container div.output_area,
div.nboutput.container div[class*=highlight],
div.nboutput.container div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    background: #f5f5f5;
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="Module-2,-Practical-8">
<h1>Module 2, Practical 8<a class="headerlink" href="#Module-2,-Practical-8" title="Permalink to this headline">¶</a></h1>
<p>In this practical we will keep working with data structures. In particular, we will see a very important and quite complex data structure called <strong>graph</strong>.</p>
<div class="section" id="Graphs">
<h2>Graphs<a class="headerlink" href="#Graphs" title="Permalink to this headline">¶</a></h2>
<div class="line-block">
<div class="line">Graphs are mathematical structures made of two key elements: <strong>nodes</strong> (or <strong>vertices</strong>) and <strong>edges</strong>.</div>
<div class="line">Nodes are objects that we want to represent and edges are relationships among these objects. Mathematically, a graph is an entity <span class="math notranslate nohighlight">\(G = (N,E)\)</span> where <span class="math notranslate nohighlight">\(N\)</span> is a set of nodes and <span class="math notranslate nohighlight">\(E = N \times N\)</span> is the set of edges.</div>
</div>
<p>Nodes are most often represented as circles, while edges (relationships) are represented by lines/arrows connecting the nodes. An example follows:</p>
<img alt="_images/graph_1.png" src="_images/graph_1.png" />
<p>Relations represented by edges can be <strong>symmetric</strong> (e.g. sibling_of: if <span class="math notranslate nohighlight">\(X\)</span> is sibling of <span class="math notranslate nohighlight">\(Y\)</span> then <span class="math notranslate nohighlight">\(Y\)</span> is sibling of <span class="math notranslate nohighlight">\(X\)</span>) and in this case the edges are just lines rather than arrows. When edges are symmetric the graph is <strong>undirected</strong>.</p>
<p>If relationships are <strong>not symmetric</strong> (i.e. <span class="math notranslate nohighlight">\(X \rightarrow Y\)</span> does not imply <span class="math notranslate nohighlight">\(Y \rightarrow X\)</span>) we put an arrow to indicate the direction of the relationship among the nodes and in this case we say the graph is <strong>directed</strong>.</p>
<p>Some terminology (from the lecture):</p>
<img alt="_images/graphTerms.png" src="_images/graphTerms.png" />
<p>The <strong>degree</strong> of a node is the number of connections it has with other nodes. In directed graphs the <strong>in-degree</strong> is the number of <strong>incoming</strong> edges, while the <strong>out-degree</strong> is the number of <strong>outgoing</strong> edges.</p>
<img alt="_images/degree.png" src="_images/degree.png" />
<p>A <strong>path</strong> in the graph is a sequence of nodes connected by edges.</p>
<img alt="_images/path.png" src="_images/path.png" />
</div>
<div class="section" id="Graph-ADT">
<h2>Graph ADT<a class="headerlink" href="#Graph-ADT" title="Permalink to this headline">¶</a></h2>
<p>Graphs are dynamic data structures in which nodes and edges can be added/removed. The description of the <em>Graph</em> Abstract Data Type follows (from the lecture):</p>
<img alt="_images/graphADT.png" src="_images/graphADT.png" />
<p>This is the most general definition, as in some cases nodes and edges can only be added and not removed.</p>
<p>There are two classic ways of implementing a Graph: <strong>adjacency matrices</strong> and <strong>linked lists</strong>.</p>
</div>
<div class="section" id="Implementation-as-adjacency-matrix">
<h2>Implementation as adjacency matrix<a class="headerlink" href="#Implementation-as-adjacency-matrix" title="Permalink to this headline">¶</a></h2>
<p>A square matrix <span class="math notranslate nohighlight">\(G\)</span> having the size <span class="math notranslate nohighlight">\(N \times N\)</span> where <span class="math notranslate nohighlight">\(N\)</span> is the number of nodes, is used to represent every possible connection among the nodes of the graph. In particular <span class="math notranslate nohighlight">\(G[i,j] = 1\)</span> if the graph has an edge connecting node <span class="math notranslate nohighlight">\(i\)</span> to node <span class="math notranslate nohighlight">\(j\)</span>, if that is not the case <span class="math notranslate nohighlight">\(G[i,j] = 0\)</span>.</p>
<p>An example of graph as adjacency matrix follows (from lecture):</p>
<img alt="_images/adjacency.png" src="_images/adjacency.png" />
<p>This representation of a graph has both advantages and disadvantages:</p>
<ul class="simple">
<li><p>it is quite <em>flexible</em> as it is possible to put weights on the values of the matrix instead of only 0 and 1;</p></li>
<li><p>it is quite <em>quick to check the presence of an edge</em> (both ways!): this just requires a lookup in the matrix G;</p></li>
<li><p>it <em>uses a lot of space</em> and most of the values often are 0 (sparse matrix, a lot of space is therefore wasted);</p></li>
<li><p>in undirected graphs, the matrix is symmetric therefore <em>half of the space could be saved</em>.</p></li>
</ul>
<p>Let’s see how we can implement a directed weighted graph as an <strong>adjacency matrix</strong> in Python.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">class</span> <span class="nc">DiGraphAsAdjacencyMatrix</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span> <span class="c1"># a set would be better, but we need an index to define</span>
                              <span class="c1"># the adjacency matrix</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gets the number of nodes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span>
    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span> <span class="n">header</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">insertNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1">#add the node if not there already.</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="c1">#add a row and a column of zeros in the matrix</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#first node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">:</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">insertEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="k">def</span> <span class="nf">deleteEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;removing an edge means setting its</span>
<span class="sd">        corresponding slot in the matrix to 0&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;removing a node means removing</span>
<span class="sd">        its corresponding row and column in the matrix&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="c1">#print(&quot;Removing {} at index {}&quot;.format(node, i))</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">:</span>
                <span class="n">row</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">adjacent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Your treat! (see exercise 1)&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Your treat! (see exercise1). Returns all the edges&quot;&quot;&quot;</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraphAsAdjacencyMatrix</span><span class="p">()</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">six</span> <span class="o">=</span> <span class="s2">&quot;Node_6&quot;</span>
        <span class="n">n_plus</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_plus</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">six</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_2&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_2&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_3&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size is: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nodes: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Matrix:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">deleteNode</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">deleteEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_2&quot;</span><span class="p">)</span>
    <span class="c1">#no effect, nodes do not exist!</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;72&quot;</span><span class="p">,</span> <span class="s2">&quot;25&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
        Node_1  Node_2  Node_3  Node_4  Node_5  Node_6
Node_1  0       0.5     0       0       0       1
Node_2  0       0       0.5     0       0       1
Node_3  0       0       0       0.5     0       1
Node_4  0       0       0       0       0.5     1
Node_5  0.5     0       0       0       0       1
Node_6  0       0       0       0       0       1

Size is: 7
Nodes: [&#39;Node_1&#39;, &#39;Node_2&#39;, &#39;Node_3&#39;, &#39;Node_4&#39;, &#39;Node_5&#39;, &#39;Node_6&#39;, &#39;Node_7&#39;]

Matrix:
        Node_1  Node_2  Node_3  Node_4  Node_5  Node_6  Node_7
Node_1  0       0.5     0       0       0       1       -1
Node_2  0       0       0.5     0       0       1       -2
Node_3  0       0       0       0.5     0       1       0
Node_4  0       0       0       0       0.5     1       0
Node_5  0.5     0       0       0       0       1       -5
Node_6  0       0       0       0       0       1       0
Node_7  0       -2      -3      0       0       0       0

        Node_1  Node_2  Node_3  Node_4  Node_5  Node_6
Node_1  0       0.5     0       0       0       1
Node_2  0       0       0.5     0       0       1
Node_3  0       0       0       0.5     0       1
Node_4  0       0       0       0       0.5     1
Node_5  0.5     0       0       0       0       1
Node_6  0       0       0       0       0       1

</pre></div></div>
</div>
<p>The matrix above represents the following graph:</p>
<img alt="_images/star.png" src="_images/star.png" />
<p>Download the complete source file: <a class="reference external" href="data_structures/DiGraphAsAdjacencyMatrix.py">DiGraphAsAdjacencyMatrix.py</a></p>
<div class="section" id="Exercises">
<h3>Exercises<a class="headerlink" href="#Exercises" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple">
<li><p>Consider the <code class="docutils literal notranslate"><span class="pre">DiGraphAsAdjacencyMatrix</span></code> graph class. Add the following methods:</p></li>
</ol>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">adjacent(self,</span> <span class="pre">node)</span></code> : given a node returns all the nodes connected to it (both incoming and outgoing);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjacentEdge(self,</span> <span class="pre">node,</span> <span class="pre">incoming=True)</span></code> : given a node, returns all the nodes close to it (incoming if “incoming=True” or outgoing if “incoming = False”) as a list of pairs (node, other, weight);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edges(self)</span></code> : returns all the edges in the graph as pairs (i,j, weight);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edgeIn(self,</span> <span class="pre">node1,</span> <span class="pre">node2)</span></code> : check if the edge node1 –&gt; node2 is in the graph;</p></li>
</ul>
<p>Test the code with:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>G = DiGraphAsAdjacencyMatrix()
for i in range(6):
    n = &quot;Node_{}&quot;.format(i+1)
    G.insertNode(n)

for i in range(0,4):
    n = &quot;Node_&quot; + str(i+1)
    six = &quot;Node_6&quot;
    n_plus = &quot;Node_&quot; + str((i+2) % 6)
    G.insertEdge(n, n_plus,0.5)
    G.insertEdge(n, six,1)
G.insertEdge(&quot;Node_5&quot;, &quot;Node_1&quot;, 0.5)
G.insertEdge(&quot;Node_5&quot;, &quot;Node_6&quot;, 1)
G.insertEdge(&quot;Node_6&quot;, &quot;Node_6&quot;, 1)


G.insertNode(&quot;Node_7&quot;)
G.insertEdge(&quot;Node_1&quot;, &quot;Node_7&quot;, -1)
G.insertEdge(&quot;Node_2&quot;, &quot;Node_7&quot;, -2)
G.insertEdge(&quot;Node_5&quot;, &quot;Node_7&quot;, -5)
G.insertEdge(&quot;Node_7&quot;, &quot;Node_2&quot;, -2)
G.insertEdge(&quot;Node_7&quot;, &quot;Node_3&quot;, -3)


G.deleteNode(&quot;Node_7&quot;)
G.deleteEdge(&quot;Node_6&quot;, &quot;Node_2&quot;)
#no effect, nodes do not exist!
G.insertEdge(&quot;72&quot;, &quot;25&quot;,3)
print(G)

print(&quot;\nNodes connected to Node_6:&quot;)
print(G.adjacent(&quot;Node_6&quot;))
print(&quot;\nNodes connected to Node_4:&quot;)
print(G.adjacent(&quot;Node_4&quot;))
print(&quot;\nNodes connected to Node_3:&quot;)
print(G.adjacent(&quot;Node_3&quot;))
print(&quot;Edges outgoing from Node_3:&quot;)
print(G.adjacentEdge(&quot;Node_3&quot;, incoming = False))
print(&quot;Edges incoming to Node_3:&quot;)
print(G.adjacentEdge(&quot;Node_3&quot;, incoming = True))
print(&quot;\nEdges incoming to Node_6:&quot;)
print(G.adjacentEdge(&quot;Node_6&quot;, incoming = True))
print(&quot;\nEdges incoming to Node_743432:&quot;)
print(G.adjacentEdge(&quot;Node_743432&quot;, incoming = True))
print(&quot;\nAll edges:&quot;)

print(G.edges())

print(&quot;\nIs (Node_4,Node_5) there? {}&quot;.format( G.edgeIn(&quot;Node_4&quot;,&quot;Node_5&quot;)))
print(&quot;Is (Node_4,Node_3) there? {}&quot;.format( G.edgeIn(&quot;Node_4&quot;,&quot;Node_3&quot;)))
print(&quot;Is (Node_3,Node_4) there? {}&quot;.format( G.edgeIn(&quot;Node_3&quot;,&quot;Node_4&quot;)))
print(&quot;Is (Node_6,Node_6) there? {}&quot;.format( G.edgeIn(&quot;Node_6&quot;,&quot;Node_6&quot;)))
</pre></div>
</div>
<div class="tggle" onclick="toggleVisibility(&#39;Ex1&#39;);"><p>Show/Hide Solution</p>
</div><div id="Ex1" style="display:none;"><div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">class</span> <span class="nc">DiGraphAsAdjacencyMatrix</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gets the number of nodes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span>
    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span> <span class="n">header</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">insertNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1">#add the node if not there.</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="c1">#add a row and a column of zeros in the matrix</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#first node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">:</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">insertEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="k">def</span> <span class="nf">deleteEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;removing an edge means to set its</span>
<span class="sd">        corresponding place in the matrix to 0&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;removing a node means removing</span>
<span class="sd">        its corresponding row and column in the matrix&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="c1">#print(&quot;Removing {} at index {}&quot;.format(node, i))</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">:</span>
                <span class="n">row</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">adjacent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a list of nodes connected to node&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="c1">#get both incoming and outgoing edges to return nodes</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)):</span>
                <span class="n">nodeJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="c1">#incoming edges</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeJ</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">adjacentEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If incoming == False we look at the row of the node,</span>
<span class="sd">        else at the column. An edge is present if weight</span>
<span class="sd">        is different from zero</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1">#if the node is present</span>
            <span class="k">if</span> <span class="n">incoming</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="n">node2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">)):</span>
                    <span class="n">node2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node2</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all the edges in the graph as triplets&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)):</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">edgeIn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if there exist an edge between node1 and node2</span>
<span class="sd">        (i.e. weight != 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span> <span class="ow">and</span> <span class="n">node2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraphAsAdjacencyMatrix</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">six</span> <span class="o">=</span> <span class="s2">&quot;Node_6&quot;</span>
        <span class="n">n_plus</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_plus</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">six</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_2&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_2&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_3&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">G</span><span class="o">.</span><span class="n">deleteNode</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">deleteEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_2&quot;</span><span class="p">)</span>
    <span class="c1">#no effect, nodes do not exist!</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;72&quot;</span><span class="p">,</span> <span class="s2">&quot;25&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Nodes connected to Node_6:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacent</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Nodes connected to Node_4:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacent</span><span class="p">(</span><span class="s2">&quot;Node_4&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Nodes connected to Node_3:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacent</span><span class="p">(</span><span class="s2">&quot;Node_3&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edges outgoing from Node_3:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacentEdge</span><span class="p">(</span><span class="s2">&quot;Node_3&quot;</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edges incoming to Node_3:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacentEdge</span><span class="p">(</span><span class="s2">&quot;Node_3&quot;</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Edges incoming to Node_6:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacentEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Edges incoming to Node_743432:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacentEdge</span><span class="p">(</span><span class="s2">&quot;Node_743432&quot;</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">All edges:&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Is (Node_4,Node_5) there? </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">G</span><span class="o">.</span><span class="n">edgeIn</span><span class="p">(</span><span class="s2">&quot;Node_4&quot;</span><span class="p">,</span><span class="s2">&quot;Node_5&quot;</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Is (Node_4,Node_3) there? </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">G</span><span class="o">.</span><span class="n">edgeIn</span><span class="p">(</span><span class="s2">&quot;Node_4&quot;</span><span class="p">,</span><span class="s2">&quot;Node_3&quot;</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Is (Node_3,Node_4) there? </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">G</span><span class="o">.</span><span class="n">edgeIn</span><span class="p">(</span><span class="s2">&quot;Node_3&quot;</span><span class="p">,</span><span class="s2">&quot;Node_4&quot;</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Is (Node_6,Node_6) there? </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">G</span><span class="o">.</span><span class="n">edgeIn</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span><span class="s2">&quot;Node_6&quot;</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
        Node_1  Node_2  Node_3  Node_4  Node_5  Node_6
Node_1  0       0.5     0       0       0       1
Node_2  0       0       0.5     0       0       1
Node_3  0       0       0       0.5     0       1
Node_4  0       0       0       0       0.5     1
Node_5  0.5     0       0       0       0       1
Node_6  0       0       0       0       0       1


Nodes connected to Node_6:
[&#39;Node_6&#39;]

Nodes connected to Node_4:
[&#39;Node_5&#39;, &#39;Node_6&#39;]

Nodes connected to Node_3:
[&#39;Node_4&#39;, &#39;Node_6&#39;]
Edges outgoing from Node_3:
[(&#39;Node_3&#39;, &#39;Node_4&#39;, 0.5), (&#39;Node_3&#39;, &#39;Node_6&#39;, 1)]
Edges incoming to Node_3:
[(&#39;Node_2&#39;, &#39;Node_3&#39;, 0.5)]

Edges incoming to Node_6:
[(&#39;Node_1&#39;, &#39;Node_6&#39;, 1), (&#39;Node_2&#39;, &#39;Node_6&#39;, 1), (&#39;Node_3&#39;, &#39;Node_6&#39;, 1), (&#39;Node_4&#39;, &#39;Node_6&#39;, 1), (&#39;Node_5&#39;, &#39;Node_6&#39;, 1), (&#39;Node_6&#39;, &#39;Node_6&#39;, 1)]

Edges incoming to Node_743432:
None

All edges:
[(&#39;Node_1&#39;, &#39;Node_2&#39;, 0.5), (&#39;Node_1&#39;, &#39;Node_6&#39;, 1), (&#39;Node_2&#39;, &#39;Node_3&#39;, 0.5), (&#39;Node_2&#39;, &#39;Node_6&#39;, 1), (&#39;Node_3&#39;, &#39;Node_4&#39;, 0.5), (&#39;Node_3&#39;, &#39;Node_6&#39;, 1), (&#39;Node_4&#39;, &#39;Node_5&#39;, 0.5), (&#39;Node_4&#39;, &#39;Node_6&#39;, 1), (&#39;Node_5&#39;, &#39;Node_1&#39;, 0.5), (&#39;Node_5&#39;, &#39;Node_6&#39;, 1), (&#39;Node_6&#39;, &#39;Node_6&#39;, 1)]

Is (Node_4,Node_5) there? True
Is (Node_4,Node_3) there? False
Is (Node_3,Node_4) there? True
Is (Node_6,Node_6) there? True
</pre></div></div>
</div>
<p>Download the complete source file: <a class="reference external" href="data_structures/DiGraphAsAdjacencyMatrixEx1.py">DiGraphAsAdjacencyMatrixEx1.py</a></p>
</div><ol class="arabic simple" start="2">
<li><p>Extend the <code class="docutils literal notranslate"><span class="pre">DiGraphAsAdjacencyMatrix</span></code> class creating a subclass <code class="docutils literal notranslate"><span class="pre">DiGraphAmAnalyzer</span></code> and adding the following methods:</p></li>
</ol>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">getTopConnected_incoming(self)</span></code>: finds the node with the highest number of in-coming connections;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">getTopConnected_outgoing(self)</span></code>: finds the node with the highest number of out-going connections;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hasPath(self,</span> <span class="pre">node1,node2)</span></code> to check if there is a path connecting node1 to node2 (if it exists return the path as a list of pair of nodes, otherwise None;</p></li>
</ul>
<p>You can test your methods with the following code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>G = DiGraphAmAnalyzer()
for i in range(6):
    n = &quot;Node_{}&quot;.format(i+1)
    G.insertNode(n)

for i in range(0,4):
    n = &quot;Node_&quot; + str(i+1)
    six = &quot;Node_6&quot;
    n_plus = &quot;Node_&quot; + str((i+2) % 6)
    G.insertEdge(n, n_plus,0.5)
    G.insertEdge(n, six,1)

G.insertEdge(&quot;Node_5&quot;, &quot;Node_1&quot;, 0.5)
G.insertEdge(&quot;Node_5&quot;, &quot;Node_6&quot;, 1)
G.insertEdge(&quot;Node_6&quot;, &quot;Node_6&quot;, 1)
print(&quot;Top connected (outgoing):&quot;)
print(G.getTopConnected_outgoing())
print(&quot;Top connected (incoming):&quot;)
print(G.getTopConnected_incoming())
print(&quot;\nAdding edge Node_5 -- 0.5 --&gt; Node_5&quot;)
G.insertEdge(&quot;Node_5&quot;, &quot;Node_5&quot;, 0.5)
print(&quot;Top connected (outgoing):&quot;)
print(G.getTopConnected_outgoing())
print(&quot;\nAre Node_1 and Node_4 connected?&quot;)
print(&quot;{}&quot;.format(G.hasPath(&quot;Node_1&quot;,&quot;Node_4&quot;)))
print(&quot;\nRemoving Node_6&quot;)
G.deleteNode(&quot;Node_6&quot;)
print(&quot;Top connected (outgoing):&quot;)
print(G.getTopConnected_outgoing())
print(&quot;Top connected (incoming):&quot;)
print(G.getTopConnected_incoming())
G.insertNode(&quot;Node_alone&quot;)
G.insertNode(&quot;Node_alone2&quot;)
G.insertEdge(&quot;Node_alone&quot;, &quot;Node_alone2&quot;, 1)

print(&quot;\nAre Node_1 and Node_alone2 connected?&quot;)
print(G.hasPath(&quot;Node_1&quot;, &quot;Node_alone2&quot;))
print(&quot;Are Node_alone2 and Node_alone connected?&quot;)
print(G.hasPath(&quot;Node_alone2&quot;, &quot;Node_alone&quot;))
</pre></div>
</div>
<div class="tggle" onclick="toggleVisibility(&#39;Ex2&#39;);"><p>Show/Hide Solution</p>
</div><div id="Ex2" style="display:none;"><div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">DiGraphAsAdjacencyMatrix</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;gets the number of nodes&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span>
    <span class="k">def</span> <span class="nf">matrix</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">header</span> <span class="o">=</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="n">n</span> <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">])</span>
        <span class="n">data</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">)):</span>
            <span class="n">data</span> <span class="o">+=</span> <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">join</span><span class="p">([</span><span class="nb">str</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">]])</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="k">return</span> <span class="s2">&quot;</span><span class="se">\t</span><span class="s2">&quot;</span><span class="o">+</span> <span class="n">header</span> <span class="o">+</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="n">data</span>

    <span class="k">def</span> <span class="nf">insertNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="c1">#add the node if not there.</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="c1">#add a row and a column of zeros in the matrix</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1">#first node</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span> <span class="o">=</span> <span class="p">[[</span><span class="mi">0</span><span class="p">]]</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">N</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">:</span>
                    <span class="n">row</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="mi">0</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">N</span><span class="p">)])</span>

    <span class="k">def</span> <span class="nf">insertEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="k">def</span> <span class="nf">deleteEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;removing an edge means to set its</span>
<span class="sd">        corresponding place in the matrix to 0&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="n">j</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">node2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">j</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span> <span class="ow">and</span> <span class="n">j</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">=</span> <span class="mi">0</span>

    <span class="k">def</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;removing a node means removing</span>
<span class="sd">        its corresponding row and column in the matrix&quot;&quot;&quot;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="c1">#print(&quot;Removing {} at index {}&quot;.format(node, i))</span>
        <span class="k">if</span> <span class="n">node</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">row</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">:</span>
                <span class="n">row</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">i</span><span class="p">)</span>


    <span class="k">def</span> <span class="nf">adjacent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a list of nodes connected to node&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
            <span class="c1">#get both incoming and outgoing edges to return nodes</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)):</span>
                <span class="n">nodeJ</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>

                <span class="c1">#incoming edges</span>
                <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">nodeJ</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">adjacentEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If incoming == False we look at the row of the node,</span>
<span class="sd">        else at the column. An edge is present if weight</span>
<span class="sd">        is different from zero</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>
        <span class="k">if</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">:</span>
            <span class="c1">#if the node is present</span>
            <span class="k">if</span> <span class="n">incoming</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">])):</span>
                    <span class="n">node2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">e</span><span class="p">]))</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">)):</span>
                    <span class="n">node2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">i</span><span class="p">]</span>
                    <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node2</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">e</span><span class="p">][</span><span class="n">i</span><span class="p">]))</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all the edges in the graph as triplets&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)):</span>
            <span class="n">start</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">i</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">j</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)):</span>
                <span class="n">end</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">j</span><span class="p">]</span>
                <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">i</span><span class="p">][</span><span class="n">j</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">start</span><span class="p">,</span> <span class="n">end</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">edgeIn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Checks if there exist an edge between node1 and node2</span>
<span class="sd">        (i.e. weight != 0)</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span> <span class="ow">and</span> <span class="n">node2</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
            <span class="n">w</span> <span class="o">=</span>  <span class="bp">self</span><span class="o">.</span><span class="n">__matrix</span><span class="p">[</span><span class="n">n1</span><span class="p">][</span><span class="n">n2</span><span class="p">]</span>

            <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>

        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">DiGraphAmAnalyzer</span><span class="p">(</span><span class="n">DiGraphAsAdjacencyMatrix</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">getTopConnected_incoming</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">topN</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1">#accumulator to count connections</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())):</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">()[</span><span class="n">node</span><span class="p">])):</span>
                <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">()[</span><span class="n">node</span><span class="p">][</span><span class="n">el</span><span class="p">]</span>
                <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                    <span class="n">conn</span><span class="p">[</span><span class="n">el</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conn</span><span class="p">))</span> <span class="k">if</span> <span class="n">conn</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">M</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">getTopConnected_outgoing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the node(s)&quot;&quot;&quot;</span>
        <span class="n">topN</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())):</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">([</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">()[</span><span class="n">node</span><span class="p">]</span> <span class="k">if</span> <span class="n">x</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">conn</span><span class="p">:</span>
                <span class="n">topN</span> <span class="o">=</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()[</span><span class="n">node</span><span class="p">]]</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">conn</span><span class="p">:</span>
                    <span class="n">topN</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()[</span><span class="n">node</span><span class="p">])</span>

        <span class="k">return</span> <span class="n">topN</span>

    <span class="k">def</span> <span class="nf">__hasPathAux__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="ow">or</span> <span class="n">node2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="n">i2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">curN</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="n">i1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">curN</span><span class="p">)</span>
                <span class="c1">#do not travel on already visited nodes</span>
                <span class="k">if</span> <span class="n">curN</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curN</span><span class="p">)</span>
                    <span class="c1">#get all outgoing nodes of Q</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">()[</span><span class="n">i1</span><span class="p">])):</span>
                        <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">matrix</span><span class="p">()[</span><span class="n">i1</span><span class="p">][</span><span class="n">edge</span><span class="p">]</span>
                        <span class="k">if</span> <span class="n">w</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">edge</span> <span class="o">==</span> <span class="n">i2</span><span class="p">:</span>
                                <span class="k">return</span> <span class="kc">True</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()[</span><span class="n">edge</span><span class="p">])</span>

            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">hasPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
        <span class="c1">#checks both paths and returns True or false</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hasPathAux__</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__hasPathAux__</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span><span class="n">node1</span><span class="p">)</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraphAmAnalyzer</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">six</span> <span class="o">=</span> <span class="s2">&quot;Node_6&quot;</span>
        <span class="n">n_plus</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_plus</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">six</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top connected (outgoing):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">getTopConnected_outgoing</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top connected (incoming):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">getTopConnected_incoming</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Adding edge Node_5 -- 0.5 --&gt; Node_5&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top connected (outgoing):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">getTopConnected_outgoing</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Are Node_1 and Node_4 connected?&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">hasPath</span><span class="p">(</span><span class="s2">&quot;Node_1&quot;</span><span class="p">,</span><span class="s2">&quot;Node_4&quot;</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Removing Node_6&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">deleteNode</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top connected (outgoing):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">getTopConnected_outgoing</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top connected (incoming):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">getTopConnected_incoming</span><span class="p">())</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="s2">&quot;Node_alone&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="s2">&quot;Node_alone2&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_alone&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_alone2&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Are Node_1 and Node_alone2 connected?&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">hasPath</span><span class="p">(</span><span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_alone2&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Are Node_alone2 and Node_alone connected?&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">hasPath</span><span class="p">(</span><span class="s2">&quot;Node_alone2&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_alone&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Top connected (outgoing):
[&#39;Node_1&#39;, &#39;Node_2&#39;, &#39;Node_3&#39;, &#39;Node_4&#39;, &#39;Node_5&#39;]
Top connected (incoming):
[&#39;Node_6&#39;]

Adding edge Node_5 -- 0.5 --&gt; Node_5
Top connected (outgoing):
[&#39;Node_5&#39;]

Are Node_1 and Node_4 connected?
True

Removing Node_6
Top connected (outgoing):
[&#39;Node_5&#39;]
Top connected (incoming):
[&#39;Node_5&#39;]

Are Node_1 and Node_alone2 connected?
False
Are Node_alone2 and Node_alone connected?
True
</pre></div></div>
</div>
<p>Download the complete source file: <a class="reference external" href="data_structures/DiGraphAmAnalyzer.py">DiGraphAmAnalyzer.py</a></p>
</div></div>
</div>
<div class="section" id="Implementation-as-(adjacency)-linked-list">
<h2>Implementation as (adjacency) linked list<a class="headerlink" href="#Implementation-as-(adjacency)-linked-list" title="Permalink to this headline">¶</a></h2>
<p>In this case a graph <span class="math notranslate nohighlight">\(G\)</span> is represented as an <strong>adjacency linked list</strong>, where each node <span class="math notranslate nohighlight">\(N\)</span> has a linked-list of nodes connected to it in <span class="math notranslate nohighlight">\(G\)</span>. In the case of directed graphs, every node contains a list of all the nodes reachable through some <strong>outgoing</strong> edges, while in the case of undirected graphs the list will be of all nodes connected together by means of an edge.</p>
<p>Some examples follow for both the cases of directed</p>
<img alt="_images/linkedlistdir.png" src="_images/linkedlistdir.png" />
<p>and undirected graphs (from lecture):</p>
<img alt="_images/linkedlistundir.png" src="_images/linkedlistundir.png" />
<p>The implementation through adjacency linked lists has both advantages and disadvantages:</p>
<ul class="simple">
<li><p>it is <em>flexible</em>, nodes can be complex objects (with the only requirement of the attribute linking to the neighboring nodes);</p></li>
<li><p>in general, <em>it uses less space</em>, only that required by the pointers encoding for the existing edges;</p></li>
<li><p>checking presence of an edge is in general <em>slower</em> (this requires going through the list of source node);</p></li>
<li><p>getting all incoming edges of a node is <em>slow</em> (requires going through all nodes!). A workaround to this problem is to store not only outgoing-edges but also incoming edges (but this requires more memory).</p></li>
</ul>
<div class="line-block">
<div class="line">Let’s see how we can implement a <em>directed weighted graph</em> as an <strong>adjacency linked list</strong> in Python.</div>
<div class="line">We will use a dictionary to represent nodes and corresponding connections.</div>
<div class="line">Therefore, we are not going to implement a linked list, but rather a <strong>dictionary of outgoing edges</strong>. That is, each node N is a dictionary of edges (the key of the dictionary is the node to which N is connected and the value is the weight).</div>
</div>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">class</span> <span class="nc">DiGraphLL</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Every node is an element in the dictionary.</span>
<span class="sd">        The key is the node id and the value is a dictionary</span>
<span class="sd">        with second node as key and the weight as value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">insertNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">test</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1">#print(&quot;Node {} added&quot;.format(node))</span>

    <span class="k">def</span> <span class="nf">insertEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">test1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">test1</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#if both nodes exist othewise don&#39;t do anything</span>
            <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">exStr</span><span class="o">=</span> <span class="s2">&quot;Edge </span><span class="si">{}</span><span class="s2"> --&gt; </span><span class="si">{}</span><span class="s2"> already existing.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">exStr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#print(&quot;Inserted {}--&gt;{} ({})&quot;.format(node1,node2,weight))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="n">node2</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="k">def</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="c1"># need to loop through all the nodes!!!</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deleteEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>

                <span class="n">ret</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> -- </span><span class="si">{}</span><span class="s2"> --&gt; </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                                                  <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">edge</span><span class="p">]),</span>
                                                  <span class="nb">str</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">adjacent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Your treat! (see exercise 3)&quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Your treat! (see exercise 3). Returns all the edges&quot;&quot;&quot;</span>


<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraphLL</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">six</span> <span class="o">=</span> <span class="s2">&quot;Node_6&quot;</span>
        <span class="n">n_plus</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_plus</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">six</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_2&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_2&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_3&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Size is: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">G</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nodes: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Graph:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">deleteNode</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">deleteEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_2&quot;</span><span class="p">)</span>
    <span class="c1">#nodes do not exist! Therefore nothing happens!</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;72&quot;</span><span class="p">,</span> <span class="s2">&quot;25&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nodes: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="n">G</span><span class="o">.</span><span class="n">deleteEdge</span><span class="p">(</span><span class="s2">&quot;72&quot;</span><span class="p">,</span><span class="s2">&quot;25&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Nodes: </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">nodes</span><span class="p">()))</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Node_1 -- 0.5 --&gt; Node_2
Node_1 -- 1 --&gt; Node_6
Node_2 -- 0.5 --&gt; Node_3
Node_2 -- 1 --&gt; Node_6
Node_3 -- 0.5 --&gt; Node_4
Node_3 -- 1 --&gt; Node_6
Node_4 -- 0.5 --&gt; Node_5
Node_4 -- 1 --&gt; Node_6
Node_5 -- 0.5 --&gt; Node_1
Node_5 -- 1 --&gt; Node_6
Node_6 -- 1 --&gt; Node_6

Size is: 7
Nodes: [&#39;Node_1&#39;, &#39;Node_2&#39;, &#39;Node_3&#39;, &#39;Node_4&#39;, &#39;Node_5&#39;, &#39;Node_6&#39;, &#39;Node_7&#39;]
Graph:
Node_1 -- 0.5 --&gt; Node_2
Node_1 -- 1 --&gt; Node_6
Node_1 -- -1 --&gt; Node_7
Node_2 -- 0.5 --&gt; Node_3
Node_2 -- 1 --&gt; Node_6
Node_2 -- -2 --&gt; Node_7
Node_3 -- 0.5 --&gt; Node_4
Node_3 -- 1 --&gt; Node_6
Node_4 -- 0.5 --&gt; Node_5
Node_4 -- 1 --&gt; Node_6
Node_5 -- 0.5 --&gt; Node_1
Node_5 -- 1 --&gt; Node_6
Node_5 -- -5 --&gt; Node_7
Node_6 -- 1 --&gt; Node_6
Node_7 -- -2 --&gt; Node_2
Node_7 -- -3 --&gt; Node_3

Node_1 -- 0.5 --&gt; Node_2
Node_1 -- 1 --&gt; Node_6
Node_2 -- 0.5 --&gt; Node_3
Node_2 -- 1 --&gt; Node_6
Node_3 -- 0.5 --&gt; Node_4
Node_3 -- 1 --&gt; Node_6
Node_4 -- 0.5 --&gt; Node_5
Node_4 -- 1 --&gt; Node_6
Node_5 -- 0.5 --&gt; Node_1
Node_5 -- 1 --&gt; Node_6
Node_6 -- 1 --&gt; Node_6

Nodes: [&#39;Node_1&#39;, &#39;Node_2&#39;, &#39;Node_3&#39;, &#39;Node_4&#39;, &#39;Node_5&#39;, &#39;Node_6&#39;]
Nodes: [&#39;Node_1&#39;, &#39;Node_2&#39;, &#39;Node_3&#39;, &#39;Node_4&#39;, &#39;Node_5&#39;, &#39;Node_6&#39;]
Node_1 -- 0.5 --&gt; Node_2
Node_1 -- 1 --&gt; Node_6
Node_2 -- 0.5 --&gt; Node_3
Node_2 -- 1 --&gt; Node_6
Node_3 -- 0.5 --&gt; Node_4
Node_3 -- 1 --&gt; Node_6
Node_4 -- 0.5 --&gt; Node_5
Node_4 -- 1 --&gt; Node_6
Node_5 -- 0.5 --&gt; Node_1
Node_5 -- 1 --&gt; Node_6
Node_6 -- 1 --&gt; Node_6

</pre></div></div>
</div>
<p>Download the complete source file: <a class="reference external" href="data_structures/DiGraphLL.py">DiGraphLL.py</a></p>
<div class="section" id="id1">
<h3>Exercises<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<ol class="arabic simple" start="3">
<li><p>Consider the <code class="docutils literal notranslate"><span class="pre">DiGraphLL</span></code> graph class. Add the following methods:</p></li>
</ol>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">adjacent(self,</span> <span class="pre">node)</span></code> : given a node returns all the nodes connected to it (both incoming and outgoing);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">adjacentEdge(self,</span> <span class="pre">node,</span> <span class="pre">incoming=True)</span></code> : given a node, returns all the nodes close to it (incoming if “incoming=True” or outgoing if “incoming = False”) as a list of pairs (node, other, weight);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edges(self)</span></code> : returns all the edges in the graph as pairs (i,j, weight);</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">edgeIn(self,</span> <span class="pre">node1,</span> <span class="pre">node2)</span></code> : check if the edge node1 –&gt; node2 is in the graph;</p></li>
</ul>
<p>Test your methods with the test code from the previous exercise, changing <code class="docutils literal notranslate"><span class="pre">DiGraphAsAdjacencyMatrix</span></code> with <code class="docutils literal notranslate"><span class="pre">DiGraphLL</span></code>.</p>
<div class="tggle" onclick="toggleVisibility(&#39;Ex3&#39;);"><p>Show/Hide Solution</p>
</div><div id="Ex3" style="display:none;"><div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="k">class</span> <span class="nc">DiGraphLL</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Every node is an element in the dictionary.</span>
<span class="sd">        The key is the node id and the value is a dictionary</span>
<span class="sd">        with second node as key and the weight as value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">insertNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">test</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1">#print(&quot;Node {} added&quot;.format(node))</span>

    <span class="k">def</span> <span class="nf">insertEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">test1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">test1</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#if both nodes exist othewise don&#39;t do anything</span>
            <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">exStr</span> <span class="o">=</span> <span class="s2">&quot;Edge </span><span class="si">{}</span><span class="s2"> --&gt; </span><span class="si">{}</span><span class="s2"> already existing.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">exStr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#print(&quot;Inserted {}--&gt;{} ({})&quot;.format(node1,node2,weight))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="n">node2</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="k">def</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="c1"># need to loop through all the nodes!!!</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deleteEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>

                <span class="n">ret</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> -- </span><span class="si">{}</span><span class="s2"> --&gt; </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                                                  <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">edge</span><span class="p">]),</span>
                                                  <span class="nb">str</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">adjacent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a list of nodes connected to node&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                    <span class="c1">#all outgoing edges</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#all incoming edges</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">edge</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">adjacentEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If incoming == False</span>
<span class="sd">        we look at the edges of the node</span>
<span class="sd">        else we need to loop through all the nodes.</span>
<span class="sd">        An edge is present if there is a</span>
<span class="sd">        corresponding entry in the dictionary.</span>
<span class="sd">        If no such nodes exist returns None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">incoming</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">otherNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">otherNode</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">otherNode</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">other</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">node</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all the edges in a list of triplets&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">edge</span><span class="p">]</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span><span class="n">edge</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">edgeIn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if edge node1 --&gt; node2 is present&quot;&quot;&quot;</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n1</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraphLL</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">six</span> <span class="o">=</span> <span class="s2">&quot;Node_6&quot;</span>
        <span class="n">n_plus</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_plus</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">six</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_2&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">5</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_2&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">2</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_3&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">)</span>

    <span class="n">G</span><span class="o">.</span><span class="n">deleteNode</span><span class="p">(</span><span class="s2">&quot;Node_7&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">deleteEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_2&quot;</span><span class="p">)</span>
    <span class="c1">#no effect, nodes do not exist!</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;72&quot;</span><span class="p">,</span> <span class="s2">&quot;25&quot;</span><span class="p">,</span><span class="mi">3</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Nodes connected to Node_6:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacent</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Nodes connected to Node_4:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacent</span><span class="p">(</span><span class="s2">&quot;Node_4&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Nodes connected to Node_3:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacent</span><span class="p">(</span><span class="s2">&quot;Node_3&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edges outgoing from Node_3:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacentEdge</span><span class="p">(</span><span class="s2">&quot;Node_3&quot;</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">False</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Edges incoming to Node_3:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacentEdge</span><span class="p">(</span><span class="s2">&quot;Node_3&quot;</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Edges incoming to Node_6:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacentEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Edges incoming to Node_743432:&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">adjacentEdge</span><span class="p">(</span><span class="s2">&quot;Node_743432&quot;</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">All edges:&quot;</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">edges</span><span class="p">())</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Is (Node_4,Node_5) there? </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">G</span><span class="o">.</span><span class="n">edgeIn</span><span class="p">(</span><span class="s2">&quot;Node_4&quot;</span><span class="p">,</span><span class="s2">&quot;Node_5&quot;</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Is (Node_4,Node_3) there? </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">G</span><span class="o">.</span><span class="n">edgeIn</span><span class="p">(</span><span class="s2">&quot;Node_4&quot;</span><span class="p">,</span><span class="s2">&quot;Node_3&quot;</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Is (Node_3,Node_4) there? </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">G</span><span class="o">.</span><span class="n">edgeIn</span><span class="p">(</span><span class="s2">&quot;Node_3&quot;</span><span class="p">,</span><span class="s2">&quot;Node_4&quot;</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Is (Node_6,Node_6) there? </span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span> <span class="n">G</span><span class="o">.</span><span class="n">edgeIn</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span><span class="s2">&quot;Node_6&quot;</span><span class="p">)))</span>
</pre></div>
</div>
</div>
<p>Download the complete source file: <a class="reference external" href="data_structures/DiGraphLLEx3.py">DiGraphLLEx3.py</a></p>
</div><ol class="arabic simple" start="4">
<li><p>Extend the <code class="docutils literal notranslate"><span class="pre">DiGraphLL</span></code> class creating a subclass <code class="docutils literal notranslate"><span class="pre">DiGraphLLAnalyzer</span></code> by adding the following methods:</p></li>
</ol>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">getTopConnected_incoming(self)</span></code>: finds the node with the highest number of in-coming connections;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">getTopConnected_outgoing(self)</span></code>: finds the node with the highest number of out-going connections;</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">hasPath(self,</span> <span class="pre">node1,node2)</span></code> to check if there is a path connecting node1 to node2 (if it exists return the path as a list of pair of nodes, otherwise None;</p></li>
</ul>
<p>Test your class with the following code:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>G = DiGraphLLAnalyzer()
    for i in range(6):
        n = &quot;Node_{}&quot;.format(i+1)
        G.insertNode(n)

    for i in range(0,4):
        n = &quot;Node_&quot; + str(i+1)
        six = &quot;Node_6&quot;
        n_plus = &quot;Node_&quot; + str((i+2) % 6)
        G.insertEdge(n, n_plus,0.5)
        G.insertEdge(n, six,1)
    G.insertEdge(&quot;Node_5&quot;, &quot;Node_1&quot;, 0.5)
    G.insertEdge(&quot;Node_5&quot;, &quot;Node_6&quot;, 1)
    G.insertEdge(&quot;Node_6&quot;, &quot;Node_6&quot;, 1)
    print(&quot;Top connected (outgoing):&quot;)
    print(G.getTopConnected_outgoing())
    print(&quot;Top connected (incoming):&quot;)
    print(G.getTopConnected_incoming())
    print(&quot;\nAdding edge Node_5 -- 0.5 --&gt; Node_5&quot;)
    G.insertEdge(&quot;Node_5&quot;, &quot;Node_5&quot;, 0.5)
    print(&quot;Top connected (outgoing):&quot;)
    print(G.getTopConnected_outgoing())
    print(&quot;\nAre Node_1 and Node_4 connected?&quot;)
    print(&quot;{}&quot;.format(G.hasPath(&quot;Node_1&quot;,&quot;Node_4&quot;)))
    print(&quot;\nRemoving Node_6&quot;)
    G.deleteNode(&quot;Node_6&quot;)
    print(&quot;Top connected (outgoing):&quot;)
    print(G.getTopConnected_outgoing())
    print(&quot;Top connected (incoming):&quot;)
    print(G.getTopConnected_incoming())
    G.insertNode(&quot;Node_alone&quot;)
    G.insertNode(&quot;Node_alone2&quot;)
    G.insertEdge(&quot;Node_alone&quot;, &quot;Node_alone2&quot;, 1)

    print(&quot;\nAre Node_1 and Node_alone2 connected?&quot;)
    print(G.hasPath(&quot;Node_1&quot;, &quot;Node_alone2&quot;))
    print(&quot;Are Node_alone2 and Node_alone connected?&quot;)
    print(G.hasPath(&quot;Node_alone2&quot;, &quot;Node_alone&quot;))
</pre></div>
</div>
<div class="tggle" onclick="toggleVisibility(&#39;Ex4&#39;);"><p>Show/Hide Solution</p>
</div><div id="Ex4" style="display:none;"><div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">deque</span>

<span class="k">class</span> <span class="nc">DiGraphLL</span><span class="p">:</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Every node is an element in the dictionary.</span>
<span class="sd">        The key is the node id and the value is a dictionary</span>
<span class="sd">        with second node as key and the weight as value</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">insertNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">test</span> <span class="o">==</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
            <span class="c1">#print(&quot;Node {} added&quot;.format(node))</span>

    <span class="k">def</span> <span class="nf">insertEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">,</span> <span class="n">weight</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">test1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">test1</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1">#if both nodes exist othewise don&#39;t do anything</span>
            <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">exStr</span> <span class="o">=</span> <span class="s2">&quot;Edge </span><span class="si">{}</span><span class="s2"> --&gt; </span><span class="si">{}</span><span class="s2"> already existing.&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">)</span>
                <span class="k">raise</span> <span class="ne">Exception</span><span class="p">(</span><span class="n">exStr</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="c1">#print(&quot;Inserted {}--&gt;{} ({})&quot;.format(node1,node2,weight))</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">][</span><span class="n">node2</span><span class="p">]</span> <span class="o">=</span> <span class="n">weight</span>

    <span class="k">def</span> <span class="nf">deleteNode</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>
        <span class="c1"># need to loop through all the nodes!!!</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">deleteEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">node2</span><span class="p">)</span>

    <span class="k">def</span> <span class="fm">__len__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">nodes</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>

    <span class="k">def</span> <span class="nf">graph</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span>

    <span class="k">def</span> <span class="fm">__str__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>

                <span class="n">ret</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="si">{}</span><span class="s2"> -- </span><span class="si">{}</span><span class="s2"> --&gt; </span><span class="si">{}</span><span class="se">\n</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="nb">str</span><span class="p">(</span><span class="n">n</span><span class="p">),</span>
                                                  <span class="nb">str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">][</span><span class="n">edge</span><span class="p">]),</span>
                                                  <span class="nb">str</span><span class="p">(</span><span class="n">edge</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">adjacent</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;returns a list of nodes connected to node&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">test</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">test</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                    <span class="c1">#all outgoing edges</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                        <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="c1">#all incoming edges</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">edge</span> <span class="o">==</span> <span class="n">node</span><span class="p">:</span>
                            <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">adjacentEdge</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node</span><span class="p">,</span> <span class="n">incoming</span> <span class="o">=</span> <span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        If incoming == False</span>
<span class="sd">        we look at the edges of the node</span>
<span class="sd">        else we need to loop through all the nodes.</span>
<span class="sd">        An edge is present if there is a</span>
<span class="sd">        corresponding entry in the dictionary.</span>
<span class="sd">        If no such nodes exist returns None</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">if</span> <span class="n">incoming</span> <span class="o">==</span> <span class="kc">False</span><span class="p">:</span>
            <span class="n">otherNode</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">otherNode</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">for</span> <span class="n">e</span> <span class="ow">in</span> <span class="n">otherNode</span><span class="p">:</span>
                    <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">e</span><span class="p">]</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span> <span class="n">e</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
                <span class="k">return</span> <span class="n">ret</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">n</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
                <span class="n">other</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">n</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node</span><span class="p">,</span><span class="kc">None</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">other</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">n</span><span class="p">,</span><span class="n">node</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span>
            <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">edges</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns all the edges in a list of triplets&quot;&quot;&quot;</span>
        <span class="n">ret</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">w</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node</span><span class="p">][</span><span class="n">edge</span><span class="p">]</span>
                <span class="n">ret</span><span class="o">.</span><span class="n">append</span><span class="p">((</span><span class="n">node</span><span class="p">,</span><span class="n">edge</span><span class="p">,</span> <span class="n">w</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">ret</span>

    <span class="k">def</span> <span class="nf">edgeIn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Checks if edge node1 --&gt; node2 is present&quot;&quot;&quot;</span>
        <span class="n">n1</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n1</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">n2</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">__nodes</span><span class="p">[</span><span class="n">node1</span><span class="p">]</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n2</span> <span class="o">!=</span> <span class="kc">None</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">True</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">False</span>

<span class="k">class</span> <span class="nc">DiGraphLLAnalyzer</span><span class="p">(</span><span class="n">DiGraphLL</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;Every node is an element in the dictionary.</span>
<span class="sd">        The key is the node id and the value is a dictionary</span>
<span class="sd">        with key second node and value the weight</span>
<span class="sd">        &quot;&quot;&quot;</span>

    <span class="k">def</span> <span class="nf">getTopConnected_incoming</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>

        <span class="n">topN</span> <span class="o">=</span> <span class="s2">&quot;&quot;</span>
        <span class="c1">#accumulator to count connections</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">*</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">())</span>
        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">for</span> <span class="n">el</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()[</span><span class="n">node</span><span class="p">]:</span>
                <span class="n">elInd</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span><span class="o">.</span><span class="n">index</span><span class="p">(</span><span class="n">el</span><span class="p">)</span>
                <span class="n">conn</span><span class="p">[</span><span class="n">elInd</span><span class="p">]</span> <span class="o">+=</span><span class="mi">1</span>
        <span class="n">M</span> <span class="o">=</span> <span class="nb">max</span><span class="p">(</span><span class="n">conn</span><span class="p">)</span>
        <span class="n">ind</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">conn</span><span class="p">))</span> <span class="k">if</span> <span class="n">conn</span><span class="p">[</span><span class="n">x</span><span class="p">]</span> <span class="o">==</span> <span class="n">M</span><span class="p">]</span>
        <span class="k">return</span> <span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()[</span><span class="n">x</span><span class="p">]</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">ind</span><span class="p">]</span>

    <span class="k">def</span> <span class="nf">getTopConnected_outgoing</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Returns the node(s)&quot;&quot;&quot;</span>
        <span class="n">topN</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">conn</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span>

        <span class="k">for</span> <span class="n">node</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="n">n</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()[</span><span class="n">node</span><span class="p">])</span>
            <span class="k">if</span> <span class="n">n</span> <span class="o">&gt;</span> <span class="n">conn</span><span class="p">:</span>
                <span class="n">topN</span> <span class="o">=</span> <span class="p">[</span><span class="n">node</span><span class="p">]</span>
                <span class="n">conn</span> <span class="o">=</span> <span class="n">n</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">n</span> <span class="o">==</span> <span class="n">conn</span><span class="p">:</span>
                    <span class="n">topN</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">topN</span>

    <span class="k">def</span> <span class="nf">hasPathAux</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">node1</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">()</span> <span class="ow">or</span> <span class="n">node2</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">nodes</span><span class="p">():</span>
            <span class="k">return</span> <span class="kc">False</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">Q</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
            <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">node1</span><span class="p">)</span>
            <span class="n">visited</span> <span class="o">=</span> <span class="nb">set</span><span class="p">()</span>
            <span class="k">while</span> <span class="nb">len</span><span class="p">(</span><span class="n">Q</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">curN</span> <span class="o">=</span> <span class="n">Q</span><span class="o">.</span><span class="n">popleft</span><span class="p">()</span>
                <span class="c1">#do not travel on already visited nodes</span>
                <span class="k">if</span> <span class="n">curN</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">visited</span><span class="p">:</span>
                    <span class="n">visited</span><span class="o">.</span><span class="n">add</span><span class="p">(</span><span class="n">curN</span><span class="p">)</span>
                    <span class="c1">#get all outgoing nodes of Q</span>
                    <span class="k">for</span> <span class="n">edge</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">graph</span><span class="p">()[</span><span class="n">curN</span><span class="p">]:</span>
                        <span class="k">if</span> <span class="n">edge</span> <span class="o">==</span> <span class="n">node2</span><span class="p">:</span>
                            <span class="k">return</span> <span class="kc">True</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">Q</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">edge</span><span class="p">)</span>

            <span class="k">return</span> <span class="kc">False</span>

    <span class="k">def</span> <span class="nf">hasPath</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">node1</span><span class="p">,</span> <span class="n">node2</span><span class="p">):</span>
        <span class="c1">#checks both paths and returns True or false</span>
        <span class="n">res</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasPathAux</span><span class="p">(</span><span class="n">node1</span><span class="p">,</span><span class="n">node2</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">res</span><span class="p">:</span>
            <span class="k">return</span> <span class="kc">True</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">hasPathAux</span><span class="p">(</span><span class="n">node2</span><span class="p">,</span><span class="n">node1</span><span class="p">)</span>

<span class="k">if</span> <span class="vm">__name__</span> <span class="o">==</span> <span class="s2">&quot;__main__&quot;</span><span class="p">:</span>
    <span class="n">G</span> <span class="o">=</span> <span class="n">DiGraphLLAnalyzer</span><span class="p">()</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">6</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="n">n</span><span class="p">)</span>

    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">4</span><span class="p">):</span>
        <span class="n">n</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
        <span class="n">six</span> <span class="o">=</span> <span class="s2">&quot;Node_6&quot;</span>
        <span class="n">n_plus</span> <span class="o">=</span> <span class="s2">&quot;Node_&quot;</span> <span class="o">+</span> <span class="nb">str</span><span class="p">((</span><span class="n">i</span><span class="o">+</span><span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="mi">6</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">n_plus</span><span class="p">,</span><span class="mf">0.5</span><span class="p">)</span>
        <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="n">n</span><span class="p">,</span> <span class="n">six</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>

    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_6&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top connected (outgoing):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">getTopConnected_outgoing</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top connected (incoming):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">getTopConnected_incoming</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Adding edge Node_5 -- 0.5 --&gt; Node_5&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_5&quot;</span><span class="p">,</span> <span class="mf">0.5</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top connected (outgoing):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">getTopConnected_outgoing</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Are Node_1 and Node_4 connected?&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="si">{}</span><span class="s2">&quot;</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">hasPath</span><span class="p">(</span><span class="s2">&quot;Node_1&quot;</span><span class="p">,</span><span class="s2">&quot;Node_4&quot;</span><span class="p">)))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Removing Node_6&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">deleteNode</span><span class="p">(</span><span class="s2">&quot;Node_6&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top connected (outgoing):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">getTopConnected_outgoing</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Top connected (incoming):&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">getTopConnected_incoming</span><span class="p">())</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Adding Node_alone and Node_alone2&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="s2">&quot;Node_alone&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertNode</span><span class="p">(</span><span class="s2">&quot;Node_alone2&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Adding Node_alone --&gt; Node_alone2&quot;</span><span class="p">)</span>
    <span class="n">G</span><span class="o">.</span><span class="n">insertEdge</span><span class="p">(</span><span class="s2">&quot;Node_alone&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_alone2&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>

    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;</span><span class="se">\n</span><span class="s2">Are Node_1 and Node_alone2 connected?&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">hasPath</span><span class="p">(</span><span class="s2">&quot;Node_1&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_alone2&quot;</span><span class="p">))</span>
    <span class="nb">print</span><span class="p">(</span><span class="s2">&quot;Are Node_alone2 and Node_alone connected?&quot;</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">G</span><span class="o">.</span><span class="n">hasPath</span><span class="p">(</span><span class="s2">&quot;Node_alone2&quot;</span><span class="p">,</span> <span class="s2">&quot;Node_alone&quot;</span><span class="p">))</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Top connected (outgoing):
[&#39;Node_1&#39;, &#39;Node_2&#39;, &#39;Node_3&#39;, &#39;Node_4&#39;, &#39;Node_5&#39;]
Top connected (incoming):
[&#39;Node_6&#39;]

Adding edge Node_5 -- 0.5 --&gt; Node_5
Top connected (outgoing):
[&#39;Node_5&#39;]

Are Node_1 and Node_4 connected?
True

Removing Node_6
Top connected (outgoing):
[&#39;Node_5&#39;]
Top connected (incoming):
[&#39;Node_5&#39;]

Adding Node_alone and Node_alone2
Adding Node_alone --&gt; Node_alone2

Are Node_1 and Node_alone2 connected?
False
Are Node_alone2 and Node_alone connected?
True
</pre></div></div>
</div>
<p>Download the complete source file: <a class="reference external" href="data_structures/DiGraphLLAnalyzer.py">DiGraphLLAnalyzer.py</a></p>
</div></div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
        <a href="M2_practical9.html" class="btn btn-neutral float-right" title="Module 2, Practical 9" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right"></span></a>
      
      
        <a href="M2_practical7.html" class="btn btn-neutral float-left" title="Module 2, Practical 7" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright # 2021 - 2021, Luca Marchetti

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>